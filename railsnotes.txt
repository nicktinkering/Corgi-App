/*
My personal notes as I go through the Rails Tutorial.
Meant to be viewed in Sublime Text with Javascript (Rails) syntax highlighting... Hahaha!
(Not perfectly formatted, but again... These are meant as my personal notes.)





%%unfinished%%
^ ctrl-f that for where left off, if unfinished
*/



MAKING A NEW RAILS APPLICATION:

	0. See https://github.com/mhartl/rails_tutorial_sublime_text
		..For great information on getting set up in sublime text and whatnot.

dont make the folder yourself-- go to parent directory, and type
	1. To begin work on a new Rails app, run:
		// >> rails new AppNameOfChoice
			// EDIT: Later, we want to suppress the default testing framework rails uses in favor of Rspec, so instead, we should create new apps with
		>>rails new AppNameOfChoice --skip-test-unit
		and it will make and AppNameOfChoice directory for you! Next, to make it a functioning rails application, you need to...
	2. install the gems using a program called bundler. you can look at these and make sure theyre set up to your liking by looking in the Gemfile. run:
		>> bundle install
		If you ever change or add gems, remember to run >>'bundle install' after changing your Gemfile!
		a. Configuring the right gems
			+ As noted in the Heroku section, you may wish to amend the sqlite/pg section.
			+ IMPORTANTLY, if we want to use 'rspec' as our testing suite, with 'capybara', we need to:
				1. add it to our gemfile as such:
					> group :development, :test do
						> gem 'rspec-rails', '2.11.0'
						> gem 'capybara', '1.1.2'
					> end
				2. Generate the appropriate files for 'rspec' to use, with:
					>> rails generate rspec:install


	3. Now youre ready to run the app in your local environment! To get it turning, run:
		>>rails server 
		+ ...And now go to localhost//:3000!
		+ It would be recommended to get its initial commit on Git now.

	4. (Not recommended) Using Scaffolding:
		a. To create a resource (users, posts, what have you), use
			>>rails generate scaffold [User(nameofresource)] [name(variableofchoice)]:string [email(variableofchoice)]:string
				+Be sure to use singular capitalized noun as the resource name.
				+After that, you can add arbitrary attributes (variables) with their type declared alongside.
				+Note an integer id will also exist and you do not need to declare it explicitly.
		/*Sidenote: The previous action created new files, and new files are not automatically added into what's being watched by Git. You will need to add them with git add . !*/
		b. Along with the files generated during this scaffolding, you get a file that will allow you to create the requisite database. So, after running the scaffold generator, run:
			>>rake db:migrate
		c. You could now go to your site at /users/ and create and view new users.

		d. To make another resource, a micropost associated with a user, we could do:
		/* Sidenote: You can run a terminal command accross multiple lines by typing a backslash and hitting enter, then continuing the command.*/
			>>rails generate scaffold Micropost content:string user_id:integer

	5. UNDOING CHANGES IN RAILS (EVEN IF YOU MIGRATED THE DB!):
	Lets say we created the Users resource, committed it, then modified some of its files, but forgot to commit those changes before generating and db:migrating the microposts resource. Heres how to undo things in rails:
		To undo the lastdatabase migration, use:
			>>rake db:rollback
		To undo a generated resource:
			>>rails destroy scaffold [Microposts(nameofresource)]

	6. MODELS abd THE DATABASE:
		/* Old: from when was doing scaffolded...
		 a. Enforcing constraints on the data of the models.
			You add a 'validation' to the model file, eg 'micropost.rb'.
			To make sure a micropost is only X char long, add:
				> validates [:content(:nameofattribute)], :length => { :maximum => 140 }

		 b. Adding associations between models.
			To make it so each micropost belongs to a user, add to its model file:
				> belongs_to :user
			And be sure to add the corresponding association to the user model...
				> has_many :microposts
			Then, when in the rails console or writing code, you can call, for example,
				>> x = User.find(1) (or User.first)
				>> x.microposts
				...To get that users microposts!
				Similarly, you can get any of their attributes with
				>> x.name >>x.email >>Micropost.find(1).content etc */
			First, you must plan what your data model will be. Do not neglect this important first step!

			Additionally, you should use test-driven development each step of the way... See '3. Rspec tests for Models.' under the RSPEC section for information!

		/1/. Creating Models, and the nature of Models
			a. The first step is to actually create a model.
			>> rails generate model User name:string email:string
			/ * >> rails generate model [Capitalizedsingularmodelname] [optionalvar:type, optionalvar2:stringorothertype,...,]* */
			b. This creates three files of note:
				> THE MODEL FILE ITSELF: app/models/[modelname].rb
				> THE DATABASE MIGRATION FILE: db/migrate/[TIMESTAMP35345_create_modelname.rb] //More info on this in section /2/ > a. Database Migrations
				> THE SPEC TESTS FOR THIS MODEL: spec/models/modelname_spec.rb //More on writing rspec tests for models in the Rspec section.

				+ We will focus on the model file itself in this section.

			c. Model file found in app/models/[modelname].rb.
				// # created with >> rails generate model User name:string email:string
				---------- SAMPLE FILE --------
				class User < ActiveRecord::Base
					attr_accessible :email, :name
				end
				-------------- EOF ------------
				+ ATTR_ACCESSIBLE: By default, all model attributes are 'accessible'. What 'attr_accessible :email, :name' does is to ensure that ONLY the name and email attributes are accessible to OUTSIDE USERS, eg people using the site, preventing mass assignment vulnerability.
				Other possible methods:
				+ VALIDATES: see 'f. Adding Validations to the model'
				+ BEFORE_SAVE: a 'callback' method. see '/c/. Standardized Capitalization of String Attributes before saving'

			d. AN ASIDE: the annotate gem
				As shown, though :email and :name are listed there, we know those arent the only data held with that model! While you could always check with the database schema file in db/schema.rb, you can also add the 'annotate' gem to your Gemfile with:

				> group :development do
					> gem 'annotate', '2.5.0'
				> end
				/* Then run bundle update && bundle install, of course! */

				...And then, to use it, run
					> bundle exec annotate
				....to change the above Model file example into this: 

				---------- SAMPLE FILE --------
				// # == Schema Information
				// #
				// # Table name: users
				// #
				// #	id         :integer       	not null, primary key
				// #	name       :string(255)
				// #	email      :string(255)
				// #	created_at :datetime
				// #	updated_at :datetime
				// #
				class User < ActiveRecord::Base
					attr_accessible :name, :email
				end
				-------------- EOF ------------
				+ You may not want all data associated with your model to be accessible with getters/setters like attr_accessible makes them, so having these notes could be handy to you....
				+ (Note that, if you want your annotations to be up-to-date, youâ€™ll have to run annotate again any time the data model changes.)

			e. Adding new attribute(s) to a model
				+ To practice TDD, you can use the .respond_to? method in your spec to test for a model having a given attribute.
				/1/. To add a new attribute to a model, you can generate a database migration as such:
					>> rails generate migration add_[attribute_name]_to_[modelnameplural] [attribute_name]:[attributetype]
					Example:
					>> rails generate migration add_password_digest_to_users password_digest:string
					+ With this pattern, Rails knows from the name of your migration what it is intended to do, and can generate the migration code for you.
					+ Specifically, Rails recognizes:
						a. '_to_users' at the end-- '_to_[modelnameplural]' tells Rails what table you wish to add to,
						b. and the second argument, 'password_digest:string' tells it what column to add.
				/2/. To add a new attribute index:
					>> rails generate migration [name of migration, ex: add_index_to_users_email]
					- In this case, Rails wont know implicitly how to handle what you want to do. Because of that, youll need to write the migration code yourself. Read more at '3. Writing your own database migrations' in the database migrations section. 
			e2. Virtual attributes 
				+ Virtual attributes are attributes on a model that only exist temporarily, in memory, without being persisted to the database.
				+ A model will still respond_to those attributes, so one should test for them in the spec.
				+ An example of these is found in the 'password' and 'password_confirmation' attributes generated by 'has_secure_password'. See '13. Authentication in Rails'. 

			f. Adding Validations to the model
				+ These go in the [modelname].rb file.
				+ If youre in the rails console, use >reload! to reload the models/database schema at any point if you changed them.
				+ Dont forget to use test-driven development! Make your tests (refer to '3. Rspec tests for Models.'), and THEN move on to implementing your validations with the following...
				0. Use the method 'validates' with various arguments as such:
					> validates :attrname, [arg1, arg2, arg3....]
					a. presence: true
						+ To ensure that this attribute is present; e.g. not blank.
					b. length: { [maximum: X, minimum: Y, ...] }
					c. format: { with: /regex/ }
					d. uniqueness: true //Does not guarantee case-insensitivity!
						uniqueness: { case_sensitive: false }
						/* BIG CAVEAT: The 'uniqueness' validator does not actually guarantee uniqueness, due to the following situation: if two requests are sent in rapid succession, such as if someone clicks a webform submission button twice, it is possible that two objects would be simultaneously created in memory and considered valid by the code, then stored in the database-- A big problem! One needs to implement a check for uniqueness on a deeper level, among other things... See Section 2: UNIQUENESS.  */

					EXAMPLE:
					------ SAMPLE FILE -----
					class User < ActiveRecord::Base
					attr_accessible :email, :name

					validates :name, presence: true,
									 length: { maximum: 50 }
					VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
					validates :email, presence: true,
										format: { with: VALID_EMAIL_REGEX },
										uniqueness: { case_sensitive: false }
					end
					---- EOF SAMPLE FILE ----

				1. When validations (or saving) fail, and 'errors' object is generated. You can get the reason for failure by calling .errors.full_messages on the model object that failed validation.
					> x = User.new
					> x.valid?
					===> false
					> x.errors.full_messages
					===> ["Name can't be blank", "Email can't be blank"] 


				2. UNIQUENESS: Three steps.
					/a/. In the object Model file, with a 'validates' test.
						> validates uniqueness: { case_sensitive: false }

					/b/. Adding database indices to that specific column/attribute.
						+ Read how to implement these in '3. Writing your own database migrations' under '/2/. The Database', '/a/ Database Migrations'
						+ An index can be added to a specific column of a given table, and then used to guarantee uniqueness on a database level, rather than just in-memory with code, to that column/attribute... With an extra caveat: databases wont necessarily enforce case-insensitivity with database indices, so we need to ensure all objects with string-type attributes are saved and stored with standardized capitalization, as noted in the next point.

					/c/. Standardized Capitalization of String Attributes before saving
						+ This is added to the model file, app/models/[modelname].rb
						+ Use a callback function, 'before_save', to ensure string attributes are given a standardized capitalization.
						------ SAMPLE FILE -----
						class User < ActiveRecord::Base
						attr_accessible :email, :name

						before_save { |user| user.email.downcase! }

						[... other code, including validations... ]
						end
						---- EOF SAMPLE FILE ----
						Method:
							a. before_save { |modelobject| [.. code.. ] }

				3. PASSWORDS: A common attribute... complex to implement. See: '13. Authentication in Rails'

			g. Using the Model (Creating Instances/Objects of it)
				0. To use the model (eg make new instances of it, eg make users or whatever), you must first run >>rake db:migrate to have Rails run the db migration file generated up there and create the User table in your database. 
					+ learn about database migrations in section "2. a. Database Migrations".
				1. You can fire up the Rails Console in sandbox mode so that everything you do wont effect your true database.
					>> rails console --sandbox
					/a/ OPTIONAL: To observe what happens in the database as you mess around, run
						>> tail -f log/development.log
						...in another terminal window, and watch it go... (This didnt work for me though?)
				2. Methods... 
					/a/. Well, these are a lot like normal classes in Ruby, with a few differences, so refer back to that section. With the User model we made earlier, we can:
						>> User.new
						>> x = User.new
						>> x.name = "Dave"
						>> x = User.new(name: "Dave", email: "bomp@ding.com") //# A hash.
						DANGEROUSLY... we could even:
						>> x.id = 5
							But we sure shouldnt, obviously! Lets look at what that made...
						>> x
						===> #<User id: 5, name: "Dave", email: "bomp@ding.com", created_at: nil, updated_at: nil> 
						The reason we are able to do this despite the 'id' not being in 'attr_accessible' is that ALL rails models are given getters and setters by default, even though in base Ruby classes 'attr_accessor' is what creates those... Rails essentially has 'attr_accessor' already set for every attribute of a data model, which it infers by looking at the database. 'attr_accessible' is additional to that, and disallows for mass assignment of the variables it is given, like if you run:
						>> x = User.new(id: 5, name: "Jade", email: "science@girlpower.net")
						... Youll find that while you wont receive an error, the 'id' attribute will not have been set-- it would be NIL! Lets look:
						>> x
						===> #<User id: nil, name: "Jade", email: "science@girlpower.net", created_at: nil, updated_at: nil> 
					/b/. HOWEVER, the differences between Rails Models and Ruby classes/objects is that models are about objects IN A DATABASE.
						1. CREATION AND DESTRUCTION:
							Things running in code/console wont be stored in the database unless you use a method to do so.
							Method summary:
							a. .save
								+ This is if you made your object with .new, etc...
								+ Tries to save model object to database (fails if validations fail).
								+ Returns true if successful.
								+ If successful, the database will set the 'id', 'created_at', 'updated_at' attributes.
							b. .destroy
								+ Deletes the object referenced..
							c. .create
								+ Parallel of .new, except it combines in .save to make one handy method.
								+ Returns the data object created, NOT a boolean.
								+ If the object is invalid, it will be returned, but not actually stored in the database.. As a hint, youll see that the id is nil.
							d. .create!
								+ Raises an exception if it fails instead of returning the invalid object.

						2. FINDING AND RETRIEVING: Methods! These work by calling [Modelname].[method]
							a. .all
							b. .first, .last
							c. .find(#) //Throws an exception if Obj with this ID doesnt exist. only to be used when you're confident that it does! IF you're not, use...
							d. .find_by_id(#) //And all its brethren..
								+ Returns nil if not found.
							e. .find_by_[attrofchoice](value) // <3 Handy!
								+ Also returns nil if not found.

						3. UPDATING:
							Just like the parallel with [.new ... .save ] and .create, there are two ways to go about updating an object in the database.
							 + Find and set to variable, set attributes individually, and then .save.
								> jade = User.find_by_name("Jade")
								> jade.email = "jade@harleyscience.org"
									+ Note that at this point, your local User variable jade differs from the User.find_by_name("Jade") in the database. If you want to revert to version of the object stored in the db, call .reload on the variable.
								> jade.save
							 + Mass assignment with a hash, using the .update_attributes method.
							Method summary:
							a. .reload
								+ can be used on either a whole object or an individual attribute, as in:
									> jade.reload //Restores this variable to the same as what its pointing to in the DB. 
									> jade.email.reload //Restores just the email of this variable to be the same as the DB's version's email attr.
							b. .update_attributes(attrhash)
								+ Can only update attributes set to be accessible with attr_accessible!
								+ Does the update and the .save in one step.
								+ As such, returns true if successful.

		/2/. The Database
			/a/ Database Migrations
				Documentation at: http://guides.rubyonrails.org/migrations.html
				 1. These files are found in db/migrate/[TIMESTAMP35345_create_modelname.rb].
					// # created by >> rails generate model User name:string email:string
					---------- SAMPLE FILE --------
					class CreateUsers < ActiveRecord::Migration
						def change
							create_table :users do |t|
								t.string :name
								t.string :email

								t.timestamps
							end
						end
					end
					-------------- EOF ------------
					+ create_table is a method that take the argument of a symbol with the name of the table to create.
						- It also uses a block (|t|) which is used to create columns in the database of various types, formatted as such:
							> t.datatype :nameofcolumn
						- t.timestamps is used to also attach two other columns: created_at and updated_at.
						- an ID is automatically added as a column to make each instance of that Data Model uniquely identifiable.
					This file, when run with >>rake db:migrate, would make a database table looking like such:
					+-------------------------+
					+		 	Users		  +
					+------------+------------+
					+ id         + integer    +
					+------------+------------+
					+ name       + string     +
					+------------+------------+
					+ email      + string     +
					+------------+------------+
					+ created_at + datetime   +
					+------------+------------+
					+ updated_at + datetime   +
					+------------+------------+

				2. RAKE DB:MIGRATE, RAKE DB:ROLLBACK, and RAKE DB:TEST:PREPARE
					>>rake db:migrate updates your database according to your most recent migration file.
					>>rake db:rollback will revert your database to the state before the most recent migration.
					>>rake db:test:prepare -- You must always run this after a migration if you want your test database to have the same changes as the development one!
					>>rake db:reset will drop and recreate the database as empty.
						/* Don't forget to run migrate and test prepare afterwards!*/

				3. Writing your own database migrations
					Cont. From 'Adding new attribute/structure to a model'
					+ To generate a database migration:
						>> rails generate migration [name of migration, ex: add_index_to_users_email]
					+ The name of the migration can be completely arbitrary, but if you fulfill certain patterns, Rails can understand what you want to do with that migration and pre-generate code for you. See 'Adding new attribute/structure to a model'.
					+ If the migration is not named according to a pre-defined pattern, you will need to fill in the migration code yourself in db/migrate/[timestamp]_migrationnameyouchose.rb
					 /* Be sure to run the migration after creating it! 
						You can look in schema.rb to see the effect of your migration. */
					---------- SAMPLE FILE --------
					class AddIndexToUsersEmail < ActiveRecord::Migration
						def change
						add_index :users, :email, unique: true
						end
					end
					------------------- EOF ----------------------
					Methods:
					a. add_index [:table], [:column], [args, for ex: unique: true]
						+ This adds an index to the specified column of the table given, which can be used to enforce uniqueness on the database level to that column with the unique:true argument. CAVEAT: Case-sensitive. More code required to ensure attribute uniqueness. See section '2. UNIQUENESS: Three steps.'
						+ Has the added benefit that it will make the 'find' method for that attribute, 'find_by_[attribute]', much more efficient.

			/b/ The Database Itself 
				+ lives in db/
				+ The Database itself (being used in development) is the development.splite3 file you will see (if using sqlite3).
					- You could open this with a GUI and peruse it if you wanted!
				+ The schema is in schema.rb, a file which greatly resembles database migration files, for good reason... It is what those migrations change! It is the definitive authority on what your database/data models actually look like. 
					---------------- SAMPLE FILE ------------------
					// # A whole lot of comments come included... Of course, this isn't a file you edit yourself!
					ActiveRecord::Schema.define(:version => 20130511153118) do

						create_table "users", :force => true do |t|
							t.string   "name"
							t.string   "email"
							t.datetime "created_at", :null => false
							t.datetime "updated_at", :null => false
						end

					end
					------------------- EOF ----------------------



	8. VIEWS //Merge this section with 10. VIEWS
		In general: 
			+ You can create views files arbitrarily in views/[controller]/ as [name].html.erb files, no console commands neccessary. Just be sure to have actions and routes as appropriate.
		
		a. Adding static pages:
			/0/. If you dont have a controller for static pages, you may wish to add one, defining 'actions' corresponding to each page.
				>>rails generate controller StaticPages home help --no-test-framework

			/2/. Otherwise, the usual way to establish a static page:
				1. Add the route in routes.rb
					> get "pages/about"
					// You must restart the server [...]
				2. Add the action in to the appropriate controller
					> def about
					> end
				3. Add the view
					+ create file about.html.erb in the views/[controller, ex pages]/ folder */

		b. Adding pages related to your Models:
			+ See '/4/. the resources method' in the Routes section for information on the routing/URIs of RESTful resources for models.
			+ See 'D. ERB Forms' for information on creating instances of models through ERB forms. 


	9. Controllers
		a. Making a Controller (without scaffolding! and without default tests, if you want to use integration tests instead):
			>>rails generate controller [pluralcapitalnameofcontroller] [(optionalactionnames)*] --no-test-framework
		
		b. Adding an action to an existing controller
			/1/. Add the action in the appropriate controller at /controllers/controllername.rb
				> def nameofaction
					> /*(any code you may wish to add)*/
				> end
			/2/. If you want a corresponding view for that action:
				1. Add the route in routes.rb, eg:
					> get "controller/action"
					or
					> match '/foobar', to "controller#action"
					/* You must restart the server any time you modify the routes files for the change to take effect in your application. */
				2. Add the view in the views/nameofcontroller/ folder, nameofaction.html.erb 

	10. VIEWS
		/THE ASSET PIPELINE/
			a. (Starting in Rails 3.1) There are three directories for static assets, each with its own purpose:
					> app/assets: assets specific to the present application
					> lib/assets: assets for libraries written by your dev team
					> vendor/assets: assets from third-party vendors
				+ Each of these has subdirectories for the respective asset classes:
					>[...]/images 
					>[...]/javascripts 
					>[...]/stylesheets
			b. Respective manifest files tell Rails how to combine all the assets in each respective directories into a single file (per directory).
				/* Sidenote: The reason it does this is that having a single file makes your website faster for visitors, as HTTP requests add a lot of overhead time each... One HTTP request for a single file is much quicker than multiple HTTP requests for multiple files, even if those files, in total, are the same size in KB or whatever as the one all-inclusive file ... */
				+ For example, the default manifest file for app-specific CSS: app/assets/stylesheets/application.css
					- The following lines are what tell Rails (via the Sprockets gem) how to combine your files:
						> /*
						   *= require_self
							   *= require_tree .
							   */
							+ The lines are fairly self-explanatory; the only potentially "surprising" thing is that they are inside a CSS comment block... And despite the usual behavior/nature of comments in code, these are not 'ignored by the compiler' and are, as such, not optional.
		/Layouts/
			a. Main Application Layout File (application.html.erb) in Modern Rails:
			The header section should have at least:
				<head>
					<title><%= [...] %></title>
					<%= stylesheet_link_tag    "application", media: "all" %>
					<%= javascript_include_tag "application" %>
					<%= csrf_meta_tags %>
					<!--[if lt IE 9]>
					<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
					<![endif]-->
				</head>
			> <%= yield %> is where a page will inject its contents into the layout.

		/Using Variables in Your Views and Layouts:
			/Option 1 -- Use a variable supplied by the Controller
				a. Define any variable you want in your controller.
				It will available to the corresponding actions view.
				+For example, to make titles dynamic. 
					In StaticPagesController, the following modification:
						>def help
							>@title = "Help"
						>end
				b. Would allow one to use @title in the view itself, a la:
					> <title> <%= @title %> </title> 
					And each variable defined in each action would be specific to that view.//
			Option 2 -- Provide a variable to other views
				a. Provide a variable in the view itself, rather than the controller, by adding this to it:
					> <% provide(:varname, 'value') %>
					and then using 
					> <%= yield(:title) %>
					to access and use it in another file (generally in a layout)!
			Option 3 -- Use a helper method
				One could augment the above technique by adding a helper method.
					> <%= full_title(yield(:title)) %>
				This would use the helper method noted in '11. Adding Helper Methods' for a more tidy default title.

		A. Embedded Ruby: General
			+ Obviously:
				> <% [...] %> runs Ruby code, but does not insert whats returned
				> <%= [...] %> runs Ruby code and inserts the return value as a string
			a. Some methods for <%= %> tags:
				/1/. stylesheet_link_tag "nameofcssfilewithextensionleftoff", :media => "all"
					+ the :media hash indicates "screen", "print", etc, like "all" here... Printing (physically) or display on screen..
					+ Second arg optional.
				/2/. link_to "text2display", 'uriofchoice/eg/#'[, method: "delete/etc..."]
					+ more optional args at end: class: "[..]"
					+ can use image_tag("img.png", alt: "txt") in place of "text2display"
					+ One can use a named route in place of a literal string URI for the second argument, for example:
						> <%= link_to "Home", root_path %>
				/3/. image_tag "img.png", alt: "txt"
				/4/. debug(params)
					+ Literally put 'params' in there. Those are the params of the page URI you are on.
					+ Outputs debug information.
				/5/. Method 'form_for(@database_modelobj)' or 'form_for(:[non-databaseModel], url: [x_path])'
					+ form_for([@existingobject])
						> allows Rails to infer that the action of the form should be to POST to the
						URI /[existingobjects], BUT in the case of something without a model, like sessions, we need to indicate the name of the resource and the corresponding URI:
					+ form_for(:[non-modelObject], url: [x]_path)
					Syntax: 
						> form_for(@obj) do |f| [..] end
					Helpers:
						> f.label :attribute, "Optional alternate display text"
						> f.text_field :attr
						> f.password_field :attr
						> f.submit
						> all of the above can also take an extra arg to add CSS classes: [..], class: "[..]"
				/6/. pluralize(#, "word")
						> pluralize(object.errors.count, "error")
				/7/. content_tag(:HTMLTAGNAME, "text"[, class: "[..]", etc])
					+ Example: content_tag(:div, value, class:"alert alert-#{key}")
			b. Useful Conditionals for Embedded Ruby
				/a/. if Rails.env.development?

		B. Partials
			+ A good way to make your code tidier and follow the DRY principle. To add a partial to your current view, use the following method:
				> <%= render "layouts/filename" %>
			+ The above causes Rails to look for a file in app/views/layouts/ called _filename.html.erb and insert its HTML content into the current view.

			b2. Partials for Model Objects
				from http://guides.rubyonrails.org/layouts_and_rendering.html
			+ If you have an instance of a model to render into a partial, you can use a shorthand syntax:
				> <%= render @user %>
			+ Assuming that the @user instance variable contains an instance of the User model, this will use _user.html.erb to render it and will pass the local variable 'user' into the partial which will refer to the @user instance variable in the parent view.

		C. Aside: CSS, and Twitter Bootstrap
			Using Twitter Bootstrap:
			/0/. Documentation
				- http://twitter.github.io/bootstrap/getting-started.html
				- http://twitter.github.io/bootstrap/scaffolding.html
				- http://twitter.github.io/bootstrap/base-css.html
				- http://twitter.github.io/bootstrap/components.html
				- http://twitter.github.io/bootstrap/javascript.html
				- http://twitter.github.io/bootstrap/customize.html
			/1/. Adding Twitter Bootstrap to a Rails App:
				+ Simply add gem 'bootstrap-sass', '2.1' to your Gemfile. Enjoy!
					/* Don't forget to run >>bundle update && bundle install and restart the server! */
				+ Your stylesheets need to be .css.SCSS for bootstrap to work its magic.
				- You need to import bootstrap into your .scss file, too. Top of file:
					> @import "bootstrap";
			/2/. If you want to use any of Bootstraps javascript functionality, youll need to put the following line in your application.js:
				> //= require bootstrap

			Adding Original CSS to your App:
			+ create a file to contain it in app/assets/stylesheets
				-ex. custom.css.scss 
			+ Anything in this directory will be automatically included as part of the application.css file. This is because of the Rails ASSET PIPELINE.

		D. ERB Forms -- creating an object with a view
			/0/. To create an object with a form on your site, presumably you would want to do so via the new action (and, as such, the new.html.erb view) of your objects controller. So, first, go to your controller and create a new instance of the object you intend to create in an instance variable for your page to flesh out.
				> def new 
					> @user = User.new 
				> end 

			/1/. Create the form in the corresponding view with ERB helper 'form_for(@obj)', which you can read about in "/5/. Method 'form_for(@modelobj)'" under the Embedded Ruby section. 

			/2/. Youll also need to then flesh out the 'create' action of your controller to handle when the form is submitted. 
					+ You should try to create a user with the params supplied, and account for either a successful save or an unsuccessful one. 
					+ The params will reside in the params hash at a key named [:modelname]
						- The structure of the params, for example, with a User object: { user: { name: "Foo", email: "foo@gs.bg", [...] } }
					+ One can use "render 'viewname'" to render a given view; note that this will not pass through that views normal controller, and it will only have the variable you defined within that action. However, we can use this with a conditional to route a successful or unsuccessful save appropriately.

					+ Example 'create' action:
						> def create
						>	@user = User.new(params[:user])
						>	if @user.save 
						>		redirect_to @user //# Could also just render the show view, with the @user variable as defined above.
						>	else 
						>		render 'new' //# Show the signup form again. The @user variable will be the one above, so form fields will be pre-filled with what was entered before (the 'new' view will use this @user variable in constructing the form. )
						>	end
						> end
			/3/. Showing error messages
				+ When an object has .save called on it and fails, it automatically gets an errors object attached to it. As such, you can go into your view (or, better, a partial) and iterate over these (an array of messages, with @obj.errors.full_messages), inserting them as desired. (Be sure to check that there are .any? first.)
				+ Additionally, Rails automatically wraps fields corresponding to errors with the CSS class 'field_with_errors', which you can use as you wish.
			/4/. Using a 'flash' on success
					+ On success, you may route a user to their profile. You may wish to use a flash to display a welcome message on account of their successful registration: the 'flash' variable is reserved for messages that you wish to appear when a user first loads a page, and not on refresh or navigation away.
					+ You can define key-value pairs for the 'flash' hash in your controller.
					+ It is convention (and handy) to insert the ERB into the application layout file, so that you will already have that in place to display any flashes you produce later on.
					Example: 
					(in controller#action)
					> flash[:success] = "Welcome!"
					(in application.html.erb)
					> <% flash.each do |key, value| %>
					> 	 <%= content_tag(:div, value, class:"alert alert-#{key}") %>
					> <% end %>

				+ Note that 'render "viewname"' within one controller does not constitute a new request, and thus navigating away will still leave the flash up for one more screen. 
				+ To fix this, use the variant of flash[], flash.now[], which lasts for one fewer request.
					> flash.now[:success] = "...."
					



	11. Adding Helper Methods
		+ Helper methods reside in app/helpers/[x]_helper.rb.
		+ The file you write your helper function in is actually arbitrary; helpers in any helper file are available to any view. 
		+ Helpers can access instance variables defined in the Controller Action like @title.
			- The reason for this is because they are in 'Modules', which are self-contained groups of function(s) that can be used by various Classes--
				in this case, Controllers automatically pass in their instance variables to the helper methods they call...
				Normally in Ruby, you have to explicitly include a module in a class, but Rails will automatically include helper modules in the Controller classes.
		a. Below is an example helper method that returns a better title for each view, using a default or encorporating a variable given with <% provide(:x, "") %>.
			Since this is used across the entire app, we will put it in application_helper.rb.
			Helper methods are just standard Ruby. Here is how they fit in:
				FILE ----
					module ApplicationHelper

						def full_title(page_title)
							base_title = "CorgiApp"
							if page_title.empty?
								base_title
							else
								"#{base_title} | #{page_title}"
							end
						end
					end
				EOF ----
			We could then use this in our main application view as described in the previous section.

	12. Routes
		Further reading material at some point: http://guides.rubyonrails.org/routing.html
		+ Routes are in config/routes.rb
		+ You can use named routes to refer to certain URIs, like variables. For example:
			> <%= link_to "go to foobar", foobar_path %>
		DEFINE ROUTES WITH:
		/1/. the get method, to make simple static URIs accessible via GET requests:
			> get 'static_pages/help'
		/2/. the match method, to make things both accessible via GET requests AND to automatically generate a named route:
			> match '/help', to: 'static_pages#help'[, via: :delete/otherhttpaction]
			- This creates a named route called 'help_path' for your use.
			- The second argument works by routing the request to the 'help' action of the 'static_pages' controller.
			- As you can see, given that youre creating a custom mapping in the first argument, this method also means a person can visit '/help' instead of 'static_pages/help', even though the true folder structure of your website is different.
			- It also creates a named route called 'help_url'; the difference is that this will insert the full 'http://domain[..etc..]/help' URI text when it is used, whereas 'help_path' will use a relative URI.
				+ 'x_path' is more reliable and it is convention to use it, EXCEPT when doing redirects-- these should use 'x_url', simply because the HTTP standard technically requires a full URI for redirects (though in practice browsers will work with either).
			- There is an optional parameter to specify which HTTP request the route should work on.
		/3/. The root path can get special treatment. Define it like this:
			> root to: 'yourcontroller#action'
		/4/. the resources method, to generate the RESTful URIs for a certain resource.
			> resources :foos
		   ===Creates===>
		   + named path   + HTTP + URI 					+ controller#action
		   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					foos	GET  	 /foos(.:format)        	foos#index
							POST   /foos(.:format)        	foos#create
				 new_foo	GET    /foos/new(.:format)    	foos#new
				edit_foo	GET    /foos/:id/edit(.:format) foos#edit
					 foo	GET    /foos/:id(.:format)    	foos#show
							PUT    /foos/:id(.:format)    	foos#update
							DELETE /foos/:id(.:format)    	foos#destroy
		   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		   + To use a named path, you must add '_path' (or '_url') to the name listed on the left.
		   + The named paths specific to one 'foo' take a 'foo' object or its id as a param.
		   + Note that this does not automatically create the views or actions... you must go do that yourself.
		   + The following section expounds on what 'REST'ful resources are.

		   Method Options:
		   1. resources :[sessions/foos], only: [:new, :create, :destroy]


		RESTFUL RESOURCES
		/1/. 'REST' architecture (favored in Rails applications) means representing data as resources that can be 'created', 'shown', 'updated', or 'destroyed'â€”four actions corresponding to the four fundamental operations 'POST', 'GET', 'PUT', and 'DELETE' defined by the HTTP standard.

	13. Authentication in Rails: Signing in, signing out, passwords...
		+ You should have a User model or equivalent for people to have accounts.

		/1/. Password Implementation
			+ Much of the machinery behind passwords in Rails is created with 'has_secure_password'-- new to Rails '3.1.'
			+ Specifically, we will be adding three attributes to our User model-- one true attribute, 'password_digest', and two virtual attributes, 'password' and 'password_confirmation'.

			a. PASSWORD DIGEST
				+ Passwords will be an attribute of the Users model. However, obviously, it is not as simple as adding a single string column/attribute alone. A number of security checks are needed, including encryption of the data actually stored-- and, in fact, proper encryption of that data means that even if an attacker gets a copy of the database, they will not be able to sign in to any given account on the website.
				+ Although 'passwords' are strings to end users, it would be a terrible idea to actually store them in plaintext, due to the ramifications if the database was compromised. What will actually be stored in the database will be an additional column called the 'password_digest', holding an encrypted value (still of datatype string). Note that the exact name 'password_digest' is necessary for 'has_secure_password' to work.
					/* "Digest" comes from the terminology of cryptographic hash functions.  */
				+ This value will be an encrypted version of the password string of the users choice. When the user inputs their password, that string will be encrypted and checked against the password_digest field, with matching encypted values indicating the password was correct.
				1. THE ACTUAL ENCRYPTION -- BCRYPT
					+ The quality of ones encryption algorithm is key to its true security. We will use a state-of-the-art hash function called 'bcrypt'-- specifically, this is used by 'has_secure_password'
					+ This requires adding the gem 'bcrypt-ruby' to our Gemfile.
						> gem 'bcrypt-ruby', '3.0.1'
						/* >> bundle update && bundle install .... 
						 If you get the warning: 
							=> make: /usr/bin/gcc-4.2: No such file or directory
						 Reinstall RVM with the 'clang' flag by running:
							>> rvm reinstall 1.9.3 --with-gcc=clang */
				2. IMPLEMENTING PASSWORD_DIGEST 
					+ For proper TDD, be sure to test for your new attribute in your spec with respond_to.
					1. Create the password_digest attribute on your User model as described in 'e. Adding new attribute(s) to a model'-- it is a string type.
						/* Don't forget to migrate your database and test database. */
			b. PASSWORD AND PASSWORD_CONFIRMATION -- 'has_secure_password'
				1. The importance of confirmation:
					- It will be important to minimize user-error when a password is created (through the signup page), so we will implement password 'confirmation'-- having a second field in which the user types their intended password a second time to confirm it is typo-free.
					- While one could technically handle this in the controller layer, it is conventional to implement confirmation in the model and use Active Record to enforce the constraint.
				2. Implementation Explanation:
					- 'has_secure_password' will generate the virtual attributes 'password' and 'password_confirmation' for us-- these will exist temporarily in memory, and we will validate them against each other before creating and storing a proper 'password_digest' for that user in the database. Usage of 'has_secure_password' will be covered in depth in a few sections.
					- Although these attributes are 'virtual', you should essentially treat them like real attributes, and write a number of spec tests for them-- being blank, matching each other, minimum length, etc...
						/* Note: in addition to testing for blankness, you should test that a password confirmation is not nil. This can't happen through a web form, but it can at the console... And M. Hartl says that you should, just to be thorough. Why we should test for being nil (and not just blank) on that attribute where we didnt on others, I don't know. */
				3. Implementation:
					- Add 'password' and 'password_confirmation' to attr_accessible so they can be made in an initialization hash from the sign-up form.
					- Add a 'validates' call for the password attribute as desired-- presence and length.
					- Add a 'validates' call for the password_confirmation attribute presence; further validations are made unneccessary by the next step, but this prevents the nil case.
					- Add 'has_secure_password' to your User model, as a function call of its own. This will: 
						+ add the 'password' and 'password_confirmation' attributes to the User model 
						+ require that they match 
						+ add an 'authenticate' method, as described in the section below

			----------------------- BEGIN SAMPLE USER.RB FILE --------------------
				class User < ActiveRecord::Base
					attr_accessible :name, :email, :password, :password_confirmation
					has_secure_password

					before_save { |user| user.email = email.downcase }

					validates :name, presence: true, length: { maximum: 50 }
					VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
					validates :email, presence: 	true,
									format:     { with: VALID_EMAIL_REGEX },
									uniqueness: { case_sensitive: false }
					validates :password, presence: true, length: { minimum: 6 }
					validates :password_confirmation, presence: true
				end
			----------------------- END SAMPLE USER.RB FILE --------------------

		/2/. Signing In
			a. Notes on User Authentication
				+ We simply need to be able to retrieve users based on their unique identifier of choice (email, username, whatever you implemented), and then authenticate them based on password entered.
				+ The first of those is easy: simply use, eg, 'find_by_email(email_entered)'
					/* You should have added an index to this attribute, making the find method much more efficient. */
				+ The second is a method that comes with 'has_secure_password', for your User model:
					> user.authenticate(password)
						- This will:
						- ...compare the password given with the encrypted password_digest
						- ...return the correct user with that unique identifier (email,etc) from the database if the password matches, or false otherwise.
						- The use would then be: > current_user = user.authenticate(password)
					// Don't forget a respond_to rspec check for your proposed method, along with tests for it doing the right thing.
			b. How signing-in works: 'Sessions' resource 
				+ Signing/logging in to a site is essentially creating something-- a session-- and this should be created as a resource, by REST conventions.
				+ The difference between this and previous resources is that, when created, this resource is not stored and persisted to the database-- instead, it is stored in the cookie of a browser. It will not have a Model.
				+ Moreover, 
					/a/. The signin form is handled by the 'new' action of the Sessions controller.
					/b/. The actual signing-in is handled by sending a POST request to the 'create' action.
					/c/. Signing-out is handled by sending a DELETE request to the 'destroy' action.

				1. To begin, generate your Controller and tests.
					>> rails generate controller Sessions --no-test-framework
					>> rails generate integration_test authentication_pages
				
				// Begin writing your tests... Start with describing the signin page, visiting its route, etc... (Obviously, you will need to do some building to get them to pass.)
				2. Create the routing
					> resources :sessions, only: [:new, :create, :destroy]
					> 	match '/signin', to: 'sessions#new'
					> 	match '/signup', to: 'users#new'
					> 	match '/signout', to: 'sessions#destroy', via: :delete

				3. Create your views, starting with 'new'.
					'NEW' VIEW (LOGIN PAGE)
						+ Because sessions are not ActiveRecord objects (stored in the database), you cant use the 'form_for' method the same way you could for those. Instead, you need to specify to form_for the name of the resource as a symbol, and then the specific URL to POST to.
							<%= form_for(:session, url: sessions_path) do |f| %>
				4. Now we need to handle the create action.
					Think about the different cases that can happen:
						a. Email address (username, etc) not in database.
						b. Email registered, but password incorrect.
						c. Email registered and password correct!
					Now remember the behavior of the authenticate method.
						+ You call the method on a User object.
						+ Authenticate will return the User itself if the password is correct, or it will return false if the password is not correct.
					These add up to the following lines in our create action:
					> def create
					> 	user = User.find_by_email(params[:session][:email].downcase) //# DONT forget to make this case-insensitive!
					> 	if user && user.authenticate(params[:session][:password])
					> 		sign_in user //# Not yet implemented
					> 		redirect_to user 
					> 	else 
					> 		flash.now[:error] = "Invalid sign-in information."
					> 		render 'new'
					> 	end
					> end

					+ Note that one cannot use .errors.full_messages, because Sessions are not ActiveRecord model objects-- they dont have such a property. You will need to manually set an error message. 
				5. Notes on the 'sign_in' method to be implemented, and the nature of signin functionality.
					+ A good bit of the signin functionality crosses the traditional MVC lines, and, in particular, several signin functions will need to be available in both controllers and views.
					+ Since the helper-method modules created by controller generation are automatically made available in Views, the best place for our sign_in functions is in the SessionsHelper module we already have; then, including that module in the ApplicationController will make it available to all controllers as well, fully solving the availability question.

					-0- As an aside, you can place the 'handle_unverified_request' method implemented below in your ApplicationController as well, to further protect against cross-site request forgery. It will start working when sign_out is implemented.

					---------application_controller.rb---------
					class ApplicationController < ActionController::Base
					  protect_from_forgery
					  include SessionsHelper

					  #// Force Signout to prevent CSRF attacks
					  def handle_unverified_request
					  	sign_out
					  	super 
					  end
					end
					------------------------------------------

			c. SESSIONS IN RAILS (BEYOND OUR OWN DEFINITION)
				0. There are a number of techniques for creating and maintaining sessions in Rails. One method uses a built-in Rails functionality, which creates a session based on a users id, which is secure, but lasts only until the browser is closed.
					It essentially does this:
						> session[:remember_token] = user.id 
							+ The session object is stored in a cookie that makes the user id available from page to page, but expires upon browser close.
							+ On each page, the application would simply call: 
						> User.find(session[:remember_token])
							+ to retrieve the user. There would be a unique session ID generated for each session object, so it would be secure against spoofing.
				1. REMEMBER_TOKEN -- how (cryptographically) and when (callback function) to make 
					+ We will use a method that involves persistant sessions-- meaning signin lasting beyond after browser close.
					+ To do this, we must generate a unique, secure 'remember_token' for each user and store it as a PERMANENT cookie in the browser.
					HOW?
					a. The 'remember_token' needs to be associated with the user and stored for future use, so it will be added as an attribute to the user model. (String data type.)
					b. Because we expect to retrieve Users based on this token, we should add it as both a column AND an index-- you will need to fill in the migration file code yourself.
						>> rails generate migration .....
							> edit file with add_index.
					c. A remember_token could, in theory, be any string that is long and random enough to be unique. To be secure, M. Hartl recommends using the urlsafe_base64 method from the SecureRandom module of the Ruby standard library. It creates a Base64 string safe for use in URIs (and hence also safe for cookies).
						>> SecureRandom.urlsafe_base64
						==> "y6C-i4lMwymC-ZodWguZYw" //# Something different every time.
					WHERE/WHEN?
					d. You should set the remember_token via a callback function, before_save. 
						+ Theoretically, you could create it with before_create instead, which would only generate one token for that user for all time-- but using before_save instead increases the security of your application, because then hijacked sessions would be made invalid whenever the user updates their information. //(A hijacked session is where a person steals another user's remember_token and uses it to be signed in as them-- if the remember_token is unchangeable for all time, this basically gains the attacker access to that account forever-- but if you make it change when a user updates their info, the true user can invalidate the hijacker's token by doing so.
							//However, site-wide SSL is the only way to prevent session hijacking.
					e. You will need to define this method, 'create_remember_token'. Note two properties of this:
						1. PRIVATE METHOD: As it is used only internally by the User model, you should create it under the 'private' keyword within user.rb. All methods below that keyword will be private.
						2. SELF: As it assigns to one of the user attributes, you will need to use 'self.attribute_foobar = ...' within it. In this case,
							> self.remember_token = SecureRandom.urlsafe_base64
							If you did not use 'self', you would be creating a local variable 'remember_token' and assigning to it instead.
							//In your test, don't forget that the token is created upon saving-- you will need to save your @user to the database in a before block.
				d. IMPLEMENTING SIGN_IN
					Overview: Our desired authentication method is to:
						+ 1. Place a remember_token as a cookie on a users browser.
						+ 2. Then, use the token to find the user record in the database as the user moves from page to page.
					This introduces two new ideas: the 'cookies' hash, and 'current_user'.
					Read about the cookies hash under 'b. cookies[]', down in 'RAILS MVC METHODS AND VARIABLES'.

					The complete sign_in method is thus:
					-----------------------
					def sign_in(user)
						cookies.permanent[:remember_token] = user.remember_token
						self.current_user = user 
					end 	
					------------------------
					On subsequent page views, we can retrieve the user with code like:
						> User.find_by_remember_token(cookies[:remember_token])
					For it to work, we must first explain and implement 'self.current_user'.
					1. CURRENT_USER 
						+ We want to create a 'current_user', accessible in both controllers and views, which will allow constructions such as <%= current_user.name %> in ERB, and redirect_to current_user in the controllers.
						+ Making this involves a few instances of short, but tricky code. See below:
					-------------------------
					def current_user=(user)
						@current_user = user 
					end
					-------------------------
						+ What this does is simply create an instance variable, "@current_user", for later use.
						+ The '=' sign is just part of the method name. 'self.current_user = [...]' is equivalent to 'self.current_user=(...)'
						+ This by itself does not solve the problem of forgetting the user page-by-page.
						+ To solve this, we use the following code:
					-------------------------
					def current_user
						@current_user ||= User.find_by_remember_token(cookies[:remember_token])
					end
					-------------------------
						+ This uses the '||=' to set the instance variable ONLY if it was currently undefined (specifically, false or nil). 

					/* Note that the login functionality wont work while you have all those users without remember tokens, if you created and inserted them into the database before implementing such. Use the console to re-save all your users with .save(validate: false) to give them remember tokens. */

				d2. THINGS TO IMPLEMENT AFTER CREATING YOUR SIGN-IN FUNCTIONALITY:
					a. SIGN_OUT 
						Dont forget to define this in the destroy method! Set the current_user to nil (in case we wish this to take effect without a redirect or new HTTP request) and use the cookies.destroy(:key) method to destroy the current remember_token cookie.
					b. AUTOMATIC SIGN-IN AFTER REGISTERING
						How strange to have to sign in manually upon first registration.
						Just stick sign_in(@user) after saving them to the database (in the controller).


				e. USING SIGNED-IN STATUS TO CHANGE LAYOUT
					+ Just use if/else ERB with testing for a user being signed in. 
					+ A custom signed_in? method would be useful, so lets make it.
					+ The logic you need is just whether or not current_user is nil, so:
					-------(also in sessions helper file)-------
					def signed_in?
						!current_user.nil?
					end 
					---------------------------------------------

					Note that the Signout link should look something like:
					<%= link_to "Sign out", signout_path, method: "delete" %>

					/* Intense. */

		/3/. Authorization, Administration
			a. Using a before_filter
				+ You can define a before_filter in your controller that will always run a specified method before the actions you specify for that filter.
				+ Syntax:
					> before_filter :name_of_method, only: [:edit(, :otheractions)]
				+ You should then have a corresponding private method within the controller, for example:
					> private 
					>	def signed_in_user
					>		redirect_to signin_url unless signed_in? //# Assuming signed_in? helper is defined elsewhere
					>	end 
				+ These can be used, for example, to enforce authorization-- one has to be signed in to view some given page, one has to be the correct user, etc.
			b. Friendly Forwarding
				+ While not strictly necessary, it improves a websites flow to have 'friendly forwarding'-- that is, if a person tries to access a protected page while not signed in, the app will temporarily store where they wanted to go despite directing them to the login page, and then sending them back to their intended location once signin is complete.
				+ To achieve this, we can use the built-in Rails session[] hash (not to be confused with our Sessions resource), which is like a cookie that expires on browser close by default.
				+ Sample implementation:
				---------------EXAMPLE FILE 1-------------
				module SessionsHelper
				[...]
					def redirect_back_or_go_to(default) //# To be used in Sessions controller, in the create action.
						redirect_to(session[:return_to] || default)
						session.delete(:return_to)
					end

					def store_location //# To be used in the signed-in before_filter of the UsersController.
						session[:return_to] = request.url
					end 
				end
				---------------END EXAMPLE----------------
				---------------EXAMPLE FILE 2-------------
				class UsersController [...]
				[..]
						def signed_in_user
							unless signed_in?
								store_location
								redirect_to signin_url, notice: "Please sign in."
							end 
						end 
				[..]
				end
				---------------END EXAMPLE----------------
				---------------EXAMPLE FILE 3-------------
				class SessionsController [..]
				[..]
					def create 
						user = User.find_by_email(params[:session][:email])
						if user && user.authenticate(params[:session][:password])
							sign_in user 
							redirect_back_or_go_to user 
						else 
							flash.now[:error] = "Invalid password/username"
							render 'new'
						end 
					end 
				[...]
				end 
				---------------END EXAMPLE----------------

	??. Miscellaneous
		FILE UPLOAD: "If your application does need to handle custom images or other file uploads, I recommend the Paperclip gem."

INFORMATION ON RUBY IN GENERAL (WITH REFERENCE TO SOME RAILS METHODS):
Tip: Use the rails API as a reference for any given method at api.rubyonrails.org.
Another good source is Rails Guides at guides.rubyonrails.org.

	0. Using the console
		a. Invoke the 'interactive ruby' console with 'irb'
		b. To include a class file you created in your console environment, use
			>> require './filename' //#leave off .rb; also, filepath is required but doesnt have to be ./ alone

	1. Variables are:
		a. declared just by naming them and assigning a value. No var prefix, etc.
			> base_title = "CorgiApp"
		b. Undefined things:
			/1/. An instance variable, such as '@title', is 'nil' by default, unless defined.
			/2/. Normal variables, though, if tried to access without declaration, throw an error.
				> super_dog ==> NameError: undefined local variable or method 'super_dog' for [...]
				> @super_dog ===> nil
		c. Scope:
			/1/. A variable will only be available within the block it is defined in, normally.
				--EXAMPLE FILE-- test.rb
				> (0..2).each do |x|
					> dogname = "allie"
					> puts "#{x} #{dogname}"
				> end
				> dogname.nil?
				===> NameError: undefined local variable or method [...]

				>> ruby test.rb
					'0 allie'
					'1 allie'
					'2 allie'
				/NameError: undefined local variable or method 'dogname' [...]/

			/2/. In some contexts, you can make it into an instance variable, and it will be available outside the block then.... See Classes and Rspec.

	2. Functions (also called methods):
		/1/. Creating them:
			a. made with the following syntax:
				> def functionname || def functionname(args)
					> ...
				> end
			b. They implicitly return the value of the last statement executed. No need to explicitly say "return" or anything, though you could.
				ex:
					> def myDogName
						> "Allie"
					> end
				...When called, it will simply return "Allie".
				However, you can explicitly say > return "Allie" and it would do the same thing.
			c. You can create them with default arguments. If nothing is passed in, the arguments default to that value, as below.
				> def bestDog(dogname = "Allie")
					> dogname
				> end
				Using this function:
				>> bestDog ==return==> "Allie"
				>> bestDog("Holly") ==return==> "Holly"
		/2/. Calling them:
			a. You can call them with or without parenthesis for their arguments,
					> stylesheet_link_tag 'mycss', :media => "all"
						or
					> stylesheet_link_tag('mycss', :media => "all")
				and if their last arg is a hash, you can write it with or without curly braces.
					> stylesheet_link_tag 'mycss', { :media => "all" }
	3. Conditionals:
		a. if/else syntax:
			> if true
				> [...]
			> else
				> [...]
			> end
		b. Combinations
			> puts "hello" if true && false  ==> prints nothing.
			> puts "hello" if true || false  ==> "hello"
			> puts "hello" unless true 		 ==> prints nothing.
			> puts "hello" unless !true 	 ==> "hello"
		c. All objects are true except false and 'nil'
		d. You can get a boolean version of anything by preceding it with !!
			>> !!0 ==> true
			>> !!"hello" ==> true (but it will throw a warning (but not error))
	4. String class:
		a. Concatenation with +
			> "foo" + "bar" => "foobar"
		b. String interpolation:
			> "#{personX} is friends with #{personY}"
			+ Will call .to_s on non-String objects to try to integrate them.
			+ Can be a good idea to call '.inspect' on whatever youre interpolating if you dont want it converted into a string somehow.
		c. Difference between single-quoted and double-quoted string, and another method:
			+ double-quotes: allows interpolation, command-characters.
				> "#{myDogName} foo\n" => 'Allie foo'[newline]
			+ single-quotes: literally whatever is inside the quotes.
				> '#{myDogName} foo\n' => "\#{myDogName} foo\\n"
			+ Another trick! Make a string with %() to automatically escape double-quotes but still allow interpolation!!
				> %(my "dog" is "named" #{myDogName}, if you know what I mean....) 
					==> "my \"dog\" is \"named\" Allie, if you know what I mean...." 
		d. Some methods:
			- .length
			- .empty?
			- .split
				+ default splits to an array via all whitespace, or can specify with .split('substrofchoice')
				> "foo bar \n       	zoop".split ==> ["foo", "bar", "zoop"]
			- :/RAILS SPECIFIC, NOT IN BASE RUBY/
				+ .blank? 
					> "    ".empty? ====> false
					> "    ".blank? ====> true
	5. Output to console uses methods:
		> 'puts' arg => (prints arg variable, returns nil)
		> 'print' will not put a newline at the end.
		> 'p' will 'puts' arg.inspect
		> 'y [object]' will print an object to console in YAML format
	6. 'nil'
		a. nil.empty? throws an error
		b. nil.to_s ==> ""
		c. nil.to_s.empty? ==> true
		d. nil.nil? ==> true
		e. :/RAILS SPECIFIC, NOT IN BASE RUBY/
			> nil.blank? ==> true
	7. Array class:
		> a = [1,3,5]
		> a[0] ==> 1
		> a = %w[1,2,4]
		> a[0] ==> "1"
		> a[-1] ==> "4"
		a. Some methods:
			- .length
			- .empty?
			- .first, .last
			- .sort, .sort!
			- .shuffle, .shuffle!
			- [array] << [item to add at end]
			- .each do |item| [...] end
				OR
			- .each { |item| [...] }
			- .map { |item| [...] }
				+ A TRICK to more conveniently return an array with some method mapped to all its values:
					> .map(&:method)
	8. Range class
		> a = 1..52 ==> 1..52
		> 1..52.to_a ==> throws an error
		> (1..52).to_a ==> [1, 2, ... 52]
		> (1..52).each do |x| [...] end
			OR
		> (1..52).each { |x| [...] }
	9. Number class
		- Obviously, integers.
		a. Methods:
			> 5.times do 
				>[...]
			> end
	10. Symbol class
		+ Lightweight string-like labels. Each is stored in memory only once.
		a. Methods:
			- .length
	11. Hash class
		+ Basically just like arrays, but indices(keys) are (any object) instead of 0...n.
		+ Hashes are a collection of key-value pairs.
		a. Syntax:
			> hashvar = {"foo" => "zingus", :foo => "dingus", 17 => [4,6,2]}
				or, if symbols are keys:
			> hashvar = { foo: "dingus", bar: "heya"  }
			+ adding new values:
				> hashvar["food"] = "tacos"
			+ Calling a key that isnt defined returns nil.
				> hashvar[:iaintmadethis] ==return==> 'nil'
			+ ...Unless you chose to create your hash in this way, setting a default value for undefined keys:
				> hashvar = Hash.new("zip")
				With the above, trying to get an undeclared key will return "zip".
		b. Hashes have no guaranteed order.
		c. Some methods:
			- .each do |key, val| [...] end
				+ ex. >puts "key #{key.inspect} had value #{val.inspect}"
			- [hash1].merge([hash2])
				+ merges hash2s key/val pairs into hash1, overwriting them.
				+ ex. 
					>> attr = { name: "Foo", email: "Bar" }
					>> attr.merge(name: "")
					==> { name: "", email: "Bar" }
	12. Ruby Classes
		a. while most built-in classes have implicit constructors with special syntax, the
			general syntax for creating new instances of a class is such:
			> s = String.new("foobar")
			Note the capitalized class name and .new method.
		b. To get an objects class:
			> s.class ===> String
		c. ..To get the class above that (the "superclass"):
			> s.class.superclass ====> Object
		d. Making your own class:
			--- BEGIN SAMPLE FILE ----
			class PalindromeTester
				# Im just using this particular class to create objects with the palindrome method.
				# This isnt really a good use of a class, but it demonstrates the basic creation of one.
				def palindrome?(str)
					str == str.reverse
				end
			end
			--- EOF SAMPLE FILE ----
			Using that:
				> p = PalindromeTester.new()
				> p.palindrome?("foo") ====>	false
				> p.palindrome?("level") ====> true
		e. Making a class with inheritance:
			--- BEGIN SAMPLE FILE ---- Note that in Ruby, # begins a comment, but I am also adding backslashes so that the syntax is highlighted as a comment in this file
			class Word < String
				//# This class makes objects that are based off of Strings, but with our additional method(s).
				def palindrome? //# We no longer need an argument, because we can reference the object with 'self'.
					self == self.reverse //# The Word object inherits the .reverse method.
				end
			end
			--- EOF SAMPLE FILE ----
			Using that:
				> foo = Word.new("foo") //# The Word class now inherits the String constructor method.
				> hannah = Word.new("hannah")
				> foo.palindrome? ====>	false
				> hannah.palindrome? ====> true
		f. Modifying a base Ruby Class...
			--- BEGIN SAMPLE FILE ---- 
			class String
				def palindrome? 
					self == self.reverse
				end
			end
			--- EOF SAMPLE FILE ----
			Now we could simply:
				> "hannah".palindrome? ===> true
			However, it is not recommended to do things like this, for claritys sake.
		g. Making a non-trivial class of your own, with instance variables, etc.
			--- BEGIN SAMPLE FILE ---- user.rb
			class User
				attr_accessor :name, :email

				def initialize(attributes = {})
					@name = attributes[:name]
					@email = attributes[:email]
				end

				def formatted_email
					"#{@name} <#{@email}>" //# returns eg "Nick <nick@ex.org>"
				end
			end
			--- EOF SAMPLE FILE ----
			Using it:
				>> irb
				>> require './user'
				>> user = User.new(:name => "Nick", :email => "nick@ex.org")

				>> user.name ==return==> "Nick"
				>> user.formatted_email ==return==> "Nick <nick@ex.org>"
				>> user.email = "nicksnewadd@gmail.com"
				>> user.formatted_email ==return==> "Nick <nicksnewadd@gmail.com>"
			Important Notes:
			1. 'attr_accessor' is a Ruby method that automatically generates getter and setter methods for 
				the instance variables you choose to make (their names passed in as symbol arguments).
				/* Mind the difference between this and attr_accessible, which is a RAILS method! The latter allows data models to have their attributes mass-assigned with a hash... */
			2. You can then set them using @varname anywhere in that instance of the object, most likely in the init method.
			3. 'initialize' is the name of the method that will be invoked by Classname.new()
			4. Using a nested hash to create an object instance:
				>> params = {}
				>> params[:user] = {:name => "Nick", :email => "nick@ex.org"}
					==creates==> {:user => {:name => "Nick", :email => "nick@ex.org"} }
					+ Note: One key in the hash, with that keys value being another hash. 
				>> nick = User.new(params[:user])
					+... Creates the same user we did manually earlier.

RAILS MVC METHODS AND VARIABLES
	VIEWS/CONTROLLERS:
		a. params[]
			+ Main hash, with variables from the URI or form input, etc.
		b. cookies[]
			+ Browser cookies.
			+ Each element in the cookie is itself a hash of a value and an optional expiration date.
			You can use:
			> cookies.permanent[:arbitrary_val] = [...]
			To make the cookie last for 20 years (just by convention).
			Example: 
				> cookies.permanent[:remember_token] = user.remember_token
			This is equivalent to:
				> cookies[:remember_token] = ( value: user.remember_token,
												expires: 20.years.from_now.utc )
		c. session[]
			+ Built-in functionality of Rails that can be thought of as virtually the same as cookies, but expiring upon browser close. Can be used to temporarily store information.
			/* Not to be confused with params[:session][:attr] of a developer-defined 'session' resource. */
		d. request 
			+ An object.
			> [..].url
				+ URL of requested page.
		e. redirect_to foobar_url[, flashhashkey: flashhashval]
			+ Ex:
				> redirect_to signin_url, info: "Please sign in."
		f. raise
			+ Debugging tool.
			+ You can use the 'raise' method to send a message to the console, for example,
				> raise method_whose_output_we_want_to_examine.inspect
			+ It will appear alongside your Rspec test with "RuntimeError: [output]"
	MODELS
		a. .respond_to?
			+ Accepts a symbol and returns true if the object responds to the given method or attribute, and false otherwise.
		b. .valid?
			+ Returns true if a model instance passes validation (and as such could be saved to the db).
		c. .dup
			+ creates a duplicate of a model object-- especially useful for uniqueness testing in spec tests.
		d. [Modelname].count
			+ number of objects of a certain model stored in the database.
		e. Digest::MD5::hexdigest(str)
			+ MD5 hash of string.
		f. .errors
			-.[..].count
			-.[..].full_messages
			-.[..].any?
		g. .save(validate: false)
			+ To save to database without validation.
			+ Useful if we need to save our users without knowing their passwords (and we dont, and wont).

VERY GENERAL OVERVIEW ON HOW RAILS WORKS:
	The /resourcename URI (by default with scaffolding) routes to the INDEX ACTION of the resourcename CONTROLLER.
	The user Controller talks to the Model (user.rb) by getting User.all, and passes that to the view with @users.
	In routes.rb,
		> resources :users
			is what creates a bunch of routes for that resource.

	In the resourcenames_controller.rb file,
		you will see the various Actions for that resource, as functions.
		For example,
			> def index 
				> @users = User.all
			> end
			+ The User model class has a method all which returns an array of all User objects in the database.
				- You can look at the User model in user.rb... Notice its empty! the .all method is inherited in the first line, that does ActiveRecord::Base.
			+ The return array of User.all is captured in @users, an instance variable.. The significance of which is that instance variables are available to the views!
	many Actions have a corresponding view (action).html.erb.

USING RSPEC, AND WRITING RSPEC TESTS:
	/* Remember: in order to get going from here, you have to added and installed the rspec and cabybera gems in your Gemfile, and have run
	>>rails generate rspec:install
	to install rspec, as was talked about in the setting-up-a-rails-app section!*/
	1. To run all tests in the spec folder, run:
		>>rspec spec/
		//Note, if we hadn't made sure RVM was 1.11.x or above, we would have to prefix commands as such:
		//>>bundle exec rspec spec/
		//One can check by running:
		//	>>rvm get head && rvm reload
		//	>>rvm -v

	ACTUALLY WRITING RSPEC TESTS:
	0. Error reference:
		+ If you get something like 'expected css [..] with text [..] to return something', and you know it should, make sure you set the subject of that test with > subject { [page, etc] } !
		+ Another useful way to debug is to stick a 'save_and_open_page;' statement into the block on which you are testing a page. You need the 'launchy' gem to use this method.


	1. You can create the 'SPEC' file (the test to be run) for any given controller in /spec/controllers/ as 'controllername_controller_spec.rb'. Rails would do it for you if you didnt pass the --no-test-framework flag.
		
		However, rspec tests in your controllers folder wont render the views for any pages by default. To fix this, you supposedly add:
			> render_views
		...under the 'describe XController do' heading. (Did not work for me)

		/a/. The general structure for tests on controllers is:
			FILE ------
				require 'spec_helper'

				describe [FoobarController] do
						describe "arbitrary string re: what the subject of this/these test/s is" do
						it "arbitrary str what this specific test does" do
						//THE FOLLOWING ARE EXAMPLES OF SOME THINGS THAT COULD BE IN A TEST
							get 'action' /* get is a method to do a GET request. action is whatever action this test should try for this controller to get to the page it wants to look at*/
							response.should be_success
								/*response is the result of the get method.
									should is a method called on response saying its argument should apply to what its called on.
									be_success is a (presumably constant) variable indicating a successful GET request.*/
						end
					end
				end
			EOF -----

	2. You can create an rspec integration_test spec with:
		>>rails generate integration_test arbitraryname
		=====> spec/requests/arbitraryname_spec.rb
		The main use of integration tests is when you need to test content of views; Controller tests, in contrast, will not render views for given actions.
		One of the advantages of integration tests is that they are not tied to one Controller in particular.
		
		/a/. The general format for a request spec test is:
			FILE ------
				require 'spec_helper'

				describe "Arbitrary Topic, eg Static Pages" do

					describe "Arbitrary Sub-Topic, eg Home Page"

						it "abtr.str.x: 'it should have the content [contentamtestingfor]'" do
							visit '/controllername/actionname'
							page.should have_content('Hello!')
						end
					end
				end
			EOF -----

		/b/. More rspec tests:
			> [page.should] have_selector("htmltagname", 
											:text => "desiredcontentstring") 
			//Weirdness-- only seems to do partial selection, not exact match. Sigh. Works like [attr*=val].
	
	
	3. Rspec tests for Models.
		/* Note that in order for your Rspec tests to see your model, you need to run
			>>rake db:test:prepare
			...Because otherwise, while your development database might be up and about... Your TEST database isn't! And it needs to be prepared after any changes to your database schema/migrations.
			*/
		Using some of the Rspec syntax learned in the next section (4. Useful methods ...):
		-- SAMPLE FILE ------
			require 'spec_helper'

			describe User do
				before { @user = User.new(name: "Example User", email: "user@example.org") }

				subject { @user }

				it { should respond_to(:name) }
				it { should respond_to(:email) }

				it { should be_valid }

				describe "when name is left blank" do 
					before { @user.name = " " }
					it { should_not be_valid }
				end
			end
		-- EOF -----



	3. Useful methods for your Rspec tests.
		/a/. Reducing Repetition with the BEFORE method.
			> before(:each) do
				>[...]
			> end
				And it will run that code before each example/describe-block of code.
				For example, to create a variable they all can use:
				> before(:each) do 
					>@base_title = "Ruby on Rails Sample App HTML Title"
				> end

				then in your tests:
				[...]
					response.should have_selector("title", :text => "#{@base_title} | Home")
				[...]
			A synonym is to use 
				> before { visit root_path }
		/b/. Reducing Repetition by setting a SUBJECT.
			+ You could keep saying page.should, page.should_not..
			+ ...Or, you could set the 'subject' of your tests in the beginning.
				> subject { page }
			+ Then, from then on, instead of page.foobar, you do:
				> it { should have_[...] }
		/c/. Reducing Repetition with SHARED EXAMPLES.
			> shared_examples_for "all_FOOBAR" do
				> it { should have_selector('h1',  	text: VAR1) }
				> it { should have_selector('title', text: helpermethodfoo(VAR2))}
			> end

			then, in any given describe "xxx" do block...
				> let(:VAR1) { 'First variable specific to this block...' }
				> let(:VAR2) { 'Second variable specific to this block...'}
				> it_should_behave_like "all_FOOBAR"
			+ Use shared_examples_for with it_should_behave_like for nicely-written, DRY tests.
		/d/. Test links with click_link
			> visit root_path
			> click_link "About"
			> page.should have_selector 'title', text: full_title('About Us')
			and buttons with click_button
		/e/. specify { some_var.should [== "some value" | be_false | etc... ] }
		/f/. let(:new_var) { "value of choice" }
			+ a convenient way to create local variables inside tests.
		/g/. expect { [...] }.not_to change([User], [:count])
			 expect { [...] }.to change([Model], [:attr_or_method]).by([val])
			 + change takes a Model and a symbol for an object or method, and calculates the result of calling that symbol on the object both before and after the block preceding it.		 
		/h/. fill_in "[Fieldname]", with: "Foobar baz"
		/i/. click_button "Button text"
		/j/. its(:attribute) { should[_not be_blank, etc] }
			+ Can be used to test an attribute of the tests subject, like 'it { }'.
	
	4. Access functions youve defined in your helpers
		/ /. Files in spec/support/ are automatically included by rspec.

		/a/. You cant access your main Application helpers in rspec specs by default. Instead, as a possible alternative, you can make your own rspec support methods in spec/support/utilities.rb. They can be parallel copies of your real helpers or entirely new methods. However, this is pretty shitty in comparison to option /b/.
		/* Remember... Rspec runs in plain Ruby! Note the .rb! */
			---- SAMPLE utilities.rb FILE ------
			def full_title(page_title)
				base_title = "Ruby on Rails Tutorial Sample App"
				if page_title.empty?
					base_title
				else
					"#{base_title} | #{page_title}"
				end
			end
			---- EOF -----
		/b/. ...Or you can just use 'include' to bring in the module.
			> include ApplicationHelperOrwhateveryoucalledit

	5. Using Model object Factories
		+ Factories are a convenient way to define many model objects and insert them into the database for testing.
		+ We can use the 'Factory Girl' gem to do this. Include the gem in your Gemfile as such, under the test group:
			> gem 'factory_girl_rails', '4.1.0'
			/* bundle update bundle install restart rails server ... */
		+ You can create your factories in spec/factories.rb, and it will automatically be loaded by Rspec.
		/1/. Syntax
			------------- SAMPLE FACTORIES.RB FILE -------------
			FactoryGirl.define do
				factory :user do
					name		"Ron Swanson"
					email		"libertarian@baconandeggs.gov"
					password 			  "eggs1234"
					password_confirmation "eggs1234"
				end
			end
			---------------- EOF SAMPLE FILE ------------------
			Methods:
			+ factory [:modelname] do [...] end
				- Tells FactoryGirl that the subsequent definition is for a Modelname object.
		/2/. Use
			+ You can then use this factory in your Rspec tests with the 'let' command.
				> let(:user) { FactoryGirl.create(:user) }
		/3/. Speed up
			+ If you are using FactoryGirl to create objects with a secure password using Bcrypt, it can take a long time to do so-- the bcrypt algorithm is designed by default for security, not speed.
			+ However, you can configure Bcrypt to switch priority to speed by adding the following to config/environments/test.rb:
				> # Speed up tests by lowering BCrypts cost function.
				> require 'bcrypt'
				> silence_warnings do 
					> BCrypt::Engine::DEFAULT_COST = BCrypt::Engine::MIN_COST
				> end

	6. Defining Utilities: Helper Functions and custom Matchers
		+ Both can be defined in our spec/support/utilities.rb file as desired for automatic inclusion, or split up and included in whichever way.
		+ You may have to restart the server after modifying the utilities file.
		/1/. Definitions 
			a. Custom Matchers 
				+ Used in the following context:
				 > ... should have_content_foobar('Opt. arg.')
				 To replace, for example,
				 > should have_selector('div.foobclass.barclass', text: 'Opt. arg.')
			b. Custom matchers 
				+ Just like normal functions.
		/2/. Custom Matchers
			---------------EXAMPLE CONTENT------------
			RSpec::Matchers.define :have_content_foobar do |arg| 
				match do |page| 
					page.should have_selector('div.foobclass.barclass', text: arg)
				end
			end
			---------------END EXAMPLE----------------
		/3/. Helper functions
			a. Defined like normal functions.
			---------------EXAMPLE CONTENT------------
				def sign_in(user)
					visit signin_path
					fill_in "Email", with: user.email 
					fill_in "Password", with: user.password
					click_button "Sign in"
					#// When not using Capybara, eg the test this helper is used in uses a HTTP request instead of visiting.
					cookies[:remember_token] = user.remember_token
				end
			---------------END EXAMPLE----------------

USING GIT:
	VERSION-CONTROL CONFIGURATION.
	1. Youll already have a gitignore file in your directory-- rails new creates it by default! Lets configure it... Well, see one of our pre-made ones for stuff to put in there-- its not standard, but its good to ignore various sorts of useless files.
	2. To initialize git in your directory:
		>>git init
		>>git add .
			-adds all files.
		(optional: to reference what has been added:
			>>git status )
	3. You next commit your changes locally-- this is completely local to your machine!
		>>git commit -m "Initial commit."
		to commit ALL files, including notice of added or removed files, do
			>>git commit -am "Message.."
		(optional: to see what has been committed,
			>>git log)
	4. Push to Github, if you want.
		0 a. You would need to make an account on Github now if you dont have one.
		0 b. Once per computer system, make sure this is done! Set your email and name:
			>>git config --global user.email (address)
			>>git config --global user.name (your name)
			- Note that the email address has to be the same as the one on your Github Account!
		1. Create a repository on the Github website for this project. 
		2. Use the second-to-last line under "Next Steps" on the resulting page to add the remote origin to your project, a la:
			>>git remote add origin https://github.com/nicktinkering/puppy_app.git
		3. Now youve added your remote origin! However, this doesnt actually put anything in your Github repository yet. To push your commits online, you have to...
			>>git push origin master

	5. Amending premature commits or messed-up messages
		To 'replace' your last commit with your current staging area (for ex you had forgotten to >>'git add .' before committing, and you wanted them in the commit, OR, you simply want to change your commit message, [+-go ahead and add them] and then run):
				>>git commit --amend [-m "..."]

	6. Pushing Further Commits, Later!
		+ Have you committed all your changes? Run:
			>>git status
			-You want to see: 
				"nothing to commit (working directory clean)"
		+ If so, go on ahead and push it up!
			>>git push
			All pushes after the first dont need 'origin master' on them.
					
	7. What about Branches?
		0. To see what branches there are, and which one you are on:
			>>git branch
		1. The general way to switch to a branch is:
			>>git checkout (name of branch)
			a. However, to create a new branch, pass in a flag as such:
			>>git checkout -b (name of branch)

		PUSH YOUR NEW BRANCH TO GITHUB with 
		>>git push origin [branchname]

		2. If you mess up and want to undo your changes on a branch, to bring your files/directory/etc back to the state they were upon the last commit, run:
					>>git checkout --force
					- (or git checkout -f) 
				= alternatively, you can do:
					>>git reset --hard HEAD
					+ but this may do something different... his prompt said "HEAD is now at 4d05813 Initial Commit" after running that
		3. If you had committed your fuckups, and want to delete the branch entirely:
			+ Switch to your master branch with
				>>git checkout master
			+ Because there are changes on that branch that havent been merged with the master, to delete it, you have to run the following:
				>>git branch -D (name of branch)
		4. HOWEVER, lets say we didnt delete nothin'. We're on the branch we made changes and commits to. To merge this back into the master, 
				a) first go back into the master:
					>>git co master
				b) merge that bad-boy!
					>>git merge (name of branch to merge)
				c) Now, if you dont want that branch anymore, you can delete it with a soft d flag, via:
					>>git branch -d (name of branch)


	
	7. MAKING CHANGES TO FILES: KEEPING GIT AWARE. 
		+ instead of the usual rm/mv/etc, prefix these commands with git!
			EX = since we are changing the file-extension on our README file, we are doing so with:
				>>git mv README.rdoc README.md

	8. GIT STATUS 
		>>'git status' shows you what files are on the table to be put in your next commit. To see what changes in those files differentiate them from your last commit....
		>>git diff
			/* Special note-- it is useful to pipe this to a file for your text editor, sublime text, for nice syntax highlighting! Try: 
			>>git diff > dif.txt && subl dif.txt
			The above command saved into an alias:
			>>gitdiff

			You could just do 
			>> git diff | subl
			instead. haha
			*/
			
DEPLOYMENT OF YOUR RAILS APP:
	So long as your code is on Git, you can use Heroku.
	To do so:
		0. Get set up on this project:
			a. Install Heroku gem.
				>>gem install heroku 
			b. (Once per machine) Add your public key.
				>>heroku keys:add
		1. Create a remote app at Heroku. Be in your git directory! This is automatically linked to your current Git project, but creating it does not push the code there yet.
			>>heroku create
				a) Optionally, if you want to rename from the nice little poetic URL they give you by default, run:
					>>heroku rename (yournameofchoice)
		2. To push it there,
			  /* !Warning! For your rails app to be compatible with heroku, you must use the pg gem in your gemfile instead of sqlite3. Advised:
				gem "sqlite3", :groups => [:development, :test]
				gem "pg", :groups => [:production]
				*/
			>>git push heroku master
		3. That just puts the code up there, though-- you need to set up a database there! To do so, run:
			>>heroku rake db:migrate
			/* As noted before, Heroku has PostgreSQL running for databases instead of SQLite3. Eventually, you should use PG in your local production or development environment to make sure things run the same. */
			// (Note that this Heroku database will be blank... Youre not populating it with your local db content. (And why would you?! Ideally, we want real people with real accounts and posts...))
